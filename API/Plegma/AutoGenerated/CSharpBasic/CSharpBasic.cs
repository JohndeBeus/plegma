//File generated by ApiGenerator Tool (CSharpBasic) on 11/08/2015 18:56:08.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Yodiwo.API.Plegma
{
    #region Generated Enums

    
    public enum PairingStates : int
    {
        
        Initial = 0,
        
        StartRequested = 1,
        
        TokensRequested = 2,
        
        TokensSentToNode = 3,
        
        Token2SentToUser = 4,
        
        Token2PostedToServer = 5,
        
        UUIDEntryRedirect = 6,
        
        Phase1Complete = 7,
        
        NextRequested = 8,
        
        Token1PostedToServer = 9,
        
        KeysSentToNode = 10,
        
        Paired = 11,
        
        Failed = 12,
    }
    
    ///<summary> 
///type of values that each Port sends / receives
///</summary>
    public enum ePortType : byte
    {
        ///<summary> 
///undefined, should not be used!
///</summary>
        Undefined = 0,
        ///<summary> 
///integer values
///</summary>
        Scalar = 1,
        ///<summary> 
///single precision floating point values
///</summary>
        Decimal = 2,
        ///<summary> 
///double precision floating point values
///</summary>
        DecimalHigh = 3,
        ///<summary> 
///boolean values (can be true/false, on/off, 1/0, etc)
///</summary>
        Boolean = 4,
        ///<summary> 
///RGB triplet in "R,G,B" format
///</summary>
        Color = 5,
        ///<summary> 
///generic string
///</summary>
        String = 6,
    }
    
    ///<summary> 
///Direction of Port
///</summary>
    public enum ioPortDirection : byte
    {
        ///<summary> 
///undefined, should not be used!
///</summary>
        Undefined = 0,
        ///<summary> 
///both Input and Output, Port will be used in both Graph Input and Output Things
///</summary>
        InputOutput = 1,
        ///<summary> 
///Output only; Port will be used only in Graph Input Things (node->cloud)
///</summary>
        Output = 2,
        ///<summary> 
///Input only; Port will be used only in Graph Output Things (cloud->node)
///</summary>
        Input = 3,
    }
    
    ///<summary> 
///ID of the API message
///</summary>
    public enum eApiType : byte
    {
        ///<summary> 
///reserved value; do not use
///</summary>
        Invalid = 0,
        ///<summary> 
///Login Request
///</summary>
        LoginReq = 1,
        ///<summary> 
///Login Response
///</summary>
        LoginRsp = 2,
        ///<summary> 
///Node Info Request (bidirectional)
///</summary>
        NodeInfoReq = 3,
        ///<summary> 
///Node Info Response or Asynchronous message (bidirectional)
///</summary>
        NodeInfoRsp = 4,
        ///<summary> 
///Things Request (bidirectional)
///</summary>
        ThingsReq = 5,
        ///<summary> 
///Things Response or Asynchronous message (bidirectional)
///</summary>
        ThingsRsp = 6,
        ///<summary> 
///Asynchronous Port Event message (bidirectional)
///</summary>
        PortEventMsg = 7,
        ///<summary> 
///Port State Request (bidirectional)
///</summary>
        PortStateReq = 8,
        ///<summary> 
///Port States Response (cloud->node)
///</summary>
        PortStateRsp = 9,
        ///<summary> 
///Active Port Keys Message (cloud->node)
///</summary>
        ActivePortKeysMsg = 10,
        ///<summary> 
///Stream Open Request
///</summary>
        StreamOpenReq = 20,
        ///<summary> 
///Stream Open Response
///</summary>
        StreanOpenRsp = 21,
        ///<summary> 
///Stream Close Request
///</summary>
        StreamCloseReq = 22,
        ///<summary> 
///Stream Close Response
///</summary>
        StreanCloseRsp = 23,
        ///<summary> 
///Mjpeg Server Start Request
///</summary>
        MjpegServerStartReq = 24,
        ///<summary> 
///Mjpeg Server Start Response
///</summary>
        MjpegServerStartRsp = 25,
        ///<summary> 
///Mjpeg Server Stop Request
///</summary>
        MjpegServerStopReq = 26,
        ///<summary> 
///Mjpeg Server Stop Response
///</summary>
        MjpegServerStopRsp = 27,
    }
    
    ///<summary> 
///Type of Node
///</summary>
    public enum eNodeType : byte
    {
        
        Unknown = 0,
        
        Gateway = 1,
        
        EndpointSingle = 2,
        
        TestGateway = 3,
        
        TestEndpoint = 4,
        
        WSEndpoint = 5,
    }
    
    ///<summary> 
///enum of possible node capabilites
///</summary>
    public enum eNodeCapa : uint
    {
        ///<summary> 
///no capabilities
///</summary>
        None = 0,
        ///<summary> 
///Node supports graph splitting
///</summary>
        SupportsGraphSplitting = 1,
    }
    
    ///<summary> 
///Internal operation ID for Yodiwo.API.Plegma.ThingsReq and Yodiwo.API.Plegma.ThingsRsp messages
///</summary>
    public enum eThingsOperation : byte
    {
        ///<summary> 
///invalid opcode
///</summary>
        Invalid = 0,
        ///<summary> 
///referenced things are to be created at receiver. If they already exist, they are updated
///</summary>
        Create = 1,
        ///<summary> 
///referenced things are to be updated at receiver. Previously existing things at endpoint are not touched If a thing referenced in the message does not already exist at receiver, nothing should happen. If existing things are to be updated, then Yodiwo.API.Plegma.eThingsOperation.Create should be used
///</summary>
        Update = 2,
        ///<summary> 
///referenced things are to be updated at receiver if they exist, created if not.
/// Previously existing things at receiver that are not in this message are *deleted*
///</summary>
        Overwrite = 3,
        ///<summary> 
///ask that the receiver deletes referenced (by the ThingKey) thing
///</summary>
        Delete = 4,
        ///<summary> 
///ask that receiver sends back its existing things as a Yodiwo.API.Plegma.ThingsRsp
///</summary>
        Get = 5,
        ///<summary> 
///ask that the receiver scans for new things and send back all results (new and old) as a Yodiwo.API.Plegma.ThingsRsp
///</summary>
        Scan = 6,
    }
    
    ///<summary> 
///Allowed operations in Yodiwo.API.Plegma.PortStateReq messages
///</summary>
    public enum ePortStateOperation : int
    {
        ///<summary> 
///reserved; should not be used
///</summary>
        Invalid = 0,
        ///<summary> 
///request array of current state for the specified PortKey(s)
///</summary>
        SpecificKeys = 1,
        ///<summary> 
///request array of current states for ports currently deployed in graphs
///</summary>
        ActivePortStates = 2,
        ///<summary> 
///request array of current states for all ports of this Node
///</summary>
        AllPortStates = 3,
    }
    
    #endregion


    #region Generated Classes

    
    public class PairingKeyLiterals 
    {
        
        public const string Uuid = "uuid";
        
        public const string Token1 = "token1";
        
        public const string Token2 = "token2";
        
        public const string NodeKey = "nodekeystr";
        
        public const string SecretKey = "secretkey";
    }
    
    
    public class PairingNodeGetTokensRequest 
    {
        
        public string uuid;
        
        public string name;
    }
    
    
    public class PairingNodeGetKeysRequest 
    {
        
        public string uuid;
        
        public string token1;
    }
    
    
    public class PairingServerResponseTokens 
    {
        
        public string token1;
        
        public string token2;
    }
    
    
    public class PairingServerResponseKeys 
    {
        
        public string nodeKey;
        
        public string secretKey;
    }
    
    
    public class PairingNodeResponsePhase1 
    {
        
        public string userNodeRegistrationUrl;
        
        public string token2;
    }
    
    ///<summary> 
///Globally unique identifier of a User
///</summary>
    public struct UserKey 
    {
        
        public string UserID;
    }
    
    ///<summary> 
///Globally unique identifier of a Node
///</summary>
    public struct NodeKey 
    {
        
        public Yodiwo.API.Plegma.UserKey UserKey;
        
        public int NodeID;
    }
    
    ///<summary> 
///Globally unique identifier of a Yodiwo.API.Plegma.Thing
///</summary>
    public struct ThingKey 
    {
        
        public Yodiwo.API.Plegma.NodeKey NodeKey;
        
        public string ThingUID;
    }
    
    ///<summary> 
///Globally unique identifier of a Yodiwo.API.Plegma.Thing's Yodiwo.API.Plegma.Port
///</summary>
    public struct PortKey 
    {
        
        public Yodiwo.API.Plegma.ThingKey ThingKey;
        
        public string PortUID;
    }
    
    
    public struct GraphDescriptorBaseKey 
    {
        
        public Yodiwo.API.Plegma.UserKey UserKey;
        
        public string Id;
    }
    
    ///<summary> 
///Globally unique identifier of a GraphDescriptor
///</summary>
    public struct GraphDescriptorKey 
    {
        
        public Yodiwo.API.Plegma.UserKey UserKey;
        
        public string Id;
        
        public int Revision;
    }
    
    ///<summary> 
///Globally unique identifier of a Graph
///</summary>
    public struct GraphKey 
    {
        
        public Yodiwo.API.Plegma.GraphDescriptorKey GraphDescriptorKey;
        
        public int GraphId;
    }
    
    ///<summary> 
///Globally unique identifier of a Graph's Block
///</summary>
    public struct BlockKey 
    {
        
        public Yodiwo.API.Plegma.GraphKey GraphKey;
        
        public int BlockId;
    }
    
    
    public class PortConfiguration 
    {
        
        public static System.Collections.Generic.Dictionary<Yodiwo.API.Plegma.ePortType, System.Type> PortTypeDict = new System.Collections.Generic.Dictionary<Yodiwo.API.Plegma.ePortType, System.Type>() { {Yodiwo.API.Plegma.ePortType.Undefined,typeof(System.Object)} ,{Yodiwo.API.Plegma.ePortType.Scalar,typeof(int)} ,{Yodiwo.API.Plegma.ePortType.Decimal,typeof(float)} ,{Yodiwo.API.Plegma.ePortType.DecimalHigh,typeof(double)} ,{Yodiwo.API.Plegma.ePortType.Boolean,typeof(bool)} ,{Yodiwo.API.Plegma.ePortType.Color,typeof(System.Tuple<int, int, int>)} ,{Yodiwo.API.Plegma.ePortType.String,typeof(string)} ,};
        
        public static System.Collections.Generic.Dictionary<Yodiwo.API.Plegma.ePortType, System.Object> PortTypeDefaultValueDict = new System.Collections.Generic.Dictionary<Yodiwo.API.Plegma.ePortType, System.Object>() { {Yodiwo.API.Plegma.ePortType.Undefined,null} ,{Yodiwo.API.Plegma.ePortType.Scalar,0} ,{Yodiwo.API.Plegma.ePortType.Decimal,0} ,{Yodiwo.API.Plegma.ePortType.DecimalHigh,0} ,{Yodiwo.API.Plegma.ePortType.Boolean,False} ,{Yodiwo.API.Plegma.ePortType.Color,new System.Tuple<int, int, int>()} ,{Yodiwo.API.Plegma.ePortType.String,""} ,};
    }
    
    ///<summary> 
///Basic Input/Output entity of a Thing Creates and sends messages towards the Yodiwo cloud service,  or receives and handles messages from the cloud. Both events occur via the Yodiwo.API.Plegma.PortEventMsgand PortEventBatchMsg messages
///</summary>
    public class Port 
    {
        ///<summary> 
///Globally unique string identifying this port; Construct it using the Yodiwo.API.Plegma.Port.PortKey constructor
///</summary>
        public string PortKey;
        ///<summary> 
///Friendly name of this Port (as it will appear in the Cyan UI and graphs)
///</summary>
        public string Name;
        ///<summary> 
///Direction (Yodiwo.API.Plegma.ioPortDirection) of Port
///</summary>
        public Yodiwo.API.Plegma.ioPortDirection ioDirection;
        ///<summary> 
///type (Yodiwo.API.Plegma.ePortType) of values that each Port sends / receives
///</summary>
        public Yodiwo.API.Plegma.ePortType Type;
        ///<summary> 
///Indicates the number of graphs this port is currently active in (i.e. number of deployed graphs that use this Port).
///On the Thing (Device) side it is meant to be read only. If 0, it means that the user has not created any stories which depend on
/// and/or trigger this Port. As such the device should not send any Yodiwo.API.Plegma.PortEventMsg messages about it
///</summary>
        public int NumOfActiveGraphs;
    }
    
    
    public class Constants 
    {
        
        public const int YPChannelPort = 5555;
    }
    
    ///<summary> 
///Configuration parameters for the thing in generic name-value pairs
///</summary>
    public struct ConfigParameter 
    {
        
        public string Name;
        
        public string Value;
    }
    
    ///<summary> 
///Collection of instructions ("hints") for how to present this thing in the Cyan UI
///</summary>
    public struct ThingUIHints 
    {
        ///<summary> 
///URI of icon to show in Cyan for this thing
///</summary>
        public string IconURI;
    }
    
    ///<summary> 
///Main representation of a Thing that can interact with the Yodiwo cloud service
///</summary>
    public class Thing 
    {
        ///<summary> 
///Globally unique Key string of this Thing
///</summary>
        public string ThingKey;
        ///<summary> 
///friendly name of this Thing
///</summary>
        public string Name;
        ///<summary> 
///list of vendor provided configuration parameters
///</summary>
        public Yodiwo.API.Plegma.ConfigParameter[] Config;
        ///<summary> 
///list of ports (inputs / outputs) that this Thing implements
///</summary>
        public Yodiwo.API.Plegma.Port[] Ports;
        ///<summary> 
///Specifies the Thing's type Yodiwo.API.Plegma.NodeModelType
///</summary>
        public string Type;
        ///<summary> 
///Specifies the Thing's block type if it's to be specially modeled in the Cyan UI It can be left null if this Thing is to be modeled by the default Cyan UI blocks In this case Output-type Ports are gathered and represented as a Cyan UI Input Thing (thing->cloud events) and Input-type Ports are gathered and represented as a Cyan UI Output Thing (cloud->thing events) Both event directions occur via the Yodiwo.API.Plegma.PortEventMsg and PortEventBatchMsg messages
///</summary>
        public string BlockType;
        ///<summary> 
///Hints for the UI system
///</summary>
        public Yodiwo.API.Plegma.ThingUIHints UIHints;
    }
    
    ///<summary> 
///Base class of an API message, from which all message classes inherit, holding info as the message's ID, the Node's Key, Version, Sequence number
///</summary>
    public class ApiMsg 
    {
        ///<summary> 
///Id of message, of type Yodiwo.API.Plegma.eApiType
///</summary>
        public Yodiwo.API.Plegma.eApiType Id;
        ///<summary> 
///Version of API, currently set to 0
///</summary>
        public int Version;
        ///<summary> 
///Sequence number of this message
///</summary>
        public int SeqNo;
        ///<summary> 
///for RPC responses only: sequence number of previous message that this message is responding to
///</summary>
        public int ResponseToSeqNo;
    }
    
    ///<summary> 
///Login Request to be used only for transports that require explicit authentication via the API itself
///</summary>
    public class LoginReq : Yodiwo.API.Plegma.ApiMsg
    {
    }
    
    ///<summary> 
///Login Response
///sends node and secret keys
///to be used only for transports that require explicit authentication via the API itself
///</summary>
    public class LoginRsp : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///NodeKey of Node
///</summary>
        public string NodeKey;
        ///<summary> 
///Secret key of Node
///</summary>
        public string SecretKey;
    }
    
    
    public class StateDescription 
    {
        
        public double Minimum;
        
        public double Maximum;
        
        public double Step;
        
        public string Pattern;
        
        public bool ReadOnly;
    }
    
    ///<summary> 
///Describes restrictions and gives information of a configuration parameter.
///</summary>
    public class ConfigDescription 
    {
        ///<summary> 
///The default value (can be null)
///</summary>
        public string DefaultValue;
        ///<summary> 
///Human readable description (can be null)
///</summary>
        public string Description;
        ///<summary> 
///Human readable label (can be null or empty)
///</summary>
        public string Label;
        ///<summary> 
///Name of the configuration parameter (must neither be null nor empty)
///</summary>
        public string Name;
        ///<summary> 
///Specifies whether the parameter is required
///</summary>
        public bool Required;
        ///<summary> 
///The data type of the parameter (can be null)
///</summary>
        public string Type;
        ///<summary> 
///Minimum value
///</summary>
        public double Minimum;
        ///<summary> 
///Maximum value 
///</summary>
        public double Maximum;
        ///<summary> 
///Change step size
///</summary>
        public double Stepsize;
        ///<summary> 
///Specifies whether the parameter is read only
///</summary>
        public bool ReadOnly;
    }
    
    ///<summary> 
///Describes restrictions and gives information of a port Yodiwo.API.Plegma.Port.
///</summary>
    public class PortDescription 
    {
        ///<summary> 
///Human readable description for this port (can be null)
///</summary>
        public string Description;
        ///<summary> 
///The unique identifier which identifies this port (must neither be null, nor empty)
///</summary>
        public string Id;
        ///<summary> 
///Human readable label (can be null)
///</summary>
        public string Label;
        ///<summary> 
///the category of this port , e.g. "TEMPERATURE" 
///</summary>
        public string Category;
        ///<summary> 
///Describes the state of this portYodiwo.API.Plegma.StateDescription
///</summary>
        public Yodiwo.API.Plegma.StateDescription State;
    }
    
    ///<summary> 
///Base class that describes a Model of a Thing Yodiwo.API.Plegma.Thing
///</summary>
    public class NodeModelType 
    {
        ///<summary> 
///The unique identifier which identifies this model (must neither be null, nor empty)
///</summary>
        public string Id;
        ///<summary> 
///Human readable name for this model
///</summary>
        public string Name;
        ///<summary> 
///Human readable description for this model
///</summary>
        public string Description;
        ///<summary> 
///Describes the configuration parameter(s) of this modelYodiwo.API.Plegma.ConfigDescription
///</summary>
        public Yodiwo.API.Plegma.ConfigDescription[] Config;
        ///<summary> 
///Describes the port(s) of this modelYodiwo.API.Plegma.PortDescription
///</summary>
        public Yodiwo.API.Plegma.PortDescription[] Port;
    }
    
    ///<summary> 
///Base class that describes a group of Thing Models Yodiwo.API.Plegma.NodeModelType
///</summary>
    public class NodeThingType 
    {
        ///<summary> 
///The unique Type Name which identifies this group (must neither be null, nor empty)
///</summary>
        public string Type;
        ///<summary> 
///Specifies whether model(s) of this group can automatically be discovered
///</summary>
        public bool Searchable;
        ///<summary> 
///Human readable description for this group
///</summary>
        public string Description;
        ///<summary> 
///Describes the model(s) of this groupYodiwo.API.Plegma.NodeModelType
///</summary>
        public Yodiwo.API.Plegma.NodeModelType[] Model;
    }
    
    ///<summary> 
///Node Info Request If sent by cloud to a node, it is to request capabilities and supported types from the node If sent by a node to the cloud, then Yodiwo.API.Plegma.NodeInfoReq.RequestedThingType must be set
///and can be used to perform discovery with the user's connected nodes (currently unavailable)
///Direction: bidirectional (Node->Cloud and Cloud->Node)
///Receiving end must reply with a Yodiwo.API.Plegma.NodeInfoRsp
///
///</summary>
    public class NodeInfoReq : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///Reserved for future use; ignore
///</summary>
        public Yodiwo.API.Plegma.NodeThingType RequestedThingType;
    }
    
    ///<summary> 
///Node Info Response Message that contains gneral information about a node including supported Node Types and Capabilities
///Direction: bidirectional (Node->Cloud and Cloud->Node)
///In response to a Yodiwo.API.Plegma.NodeInfoReq
///</summary>
    public class NodeInfoRsp : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///Friendly name of responding Node
///</summary>
        public string Name;
        ///<summary> 
///Type (Yodiwo.API.Plegma.eNodeType) of responding Node
///</summary>
        public Yodiwo.API.Plegma.eNodeType Type;
        ///<summary> 
///Capabilities of this node
///</summary>
        public Yodiwo.API.Plegma.eNodeCapa Capabilities;
        ///<summary> 
///List of Yodiwo.API.Plegma.NodeThingTypes that this Node presents and implements
///</summary>
        public Yodiwo.API.Plegma.NodeThingType[] ThingTypes;
    }
    
    ///<summary> 
///Node Things Request Used to request a Yodiwo.API.Plegma.Things related operation from the other end.
///Receiving side *must* reply with a Yodiwo.API.Plegma.ThingsRsp.
/// Its Yodiwo.API.Plegma.ApiMsg.ResponseToSeqNo field *must* be set to this message's Yodiwo.API.Plegma.ApiMsg.SeqNo
///Direction: bidirectional (Node->Cloud and Cloud->Node)
///
///</summary>
    public class ThingsReq : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///Identifier of the operation requested; see Yodiwo.API.Plegma.eThingsOperation
///</summary>
        public Yodiwo.API.Plegma.eThingsOperation Operation;
        ///<summary> 
///Yodiwo.API.Plegma.ThingsReq.ThingKey of the Yodiwo.API.Plegma.Thing that this request refers to. If left null (invalid ThingKey)
///then this operation refers to all of the Node's Things
///</summary>
        public string ThingKey;
        ///<summary> 
///Optional: Array of Yodiwo.API.Plegma.Thing that contain information related to the request's Operation
///</summary>
        public Yodiwo.API.Plegma.Thing[] Data;
    }
    
    ///<summary> 
///Node Things Response Response to a Yodiwo.API.Plegma.ThingsReq request
///a ThingsRsp message should have:  - Yodiwo.API.Plegma.ThingsRsp.Operation set to ThingReq's operation
/// - Yodiwo.API.Plegma.ApiMsg.ResponseToSeqNo set to ThingReq's Yodiwo.API.Plegma.ApiMsg.SeqNo- Yodiwo.API.Plegma.ThingsRsp.Status set to True if ThingsReq was successfully handled and this Msg has valid data, False otherwise
/// - if Yodiwo.API.Plegma.ThingsRsp.Status is True, Yodiwo.API.Plegma.ThingsRsp.Data set to correspond to requested Req's operation, set to Null otherwise. Yodiwo.API.Plegma.ThingsRsp.Data is allowed to be null if originally requested operation does not expect back data, only status
///Direction: bidirectional (Node->Cloud and Cloud->Node)
///
///</summary>
    public class ThingsRsp : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///Identifier of this message's operation of type Yodiwo.API.Plegma.eThingsOperationOperation fields must match between Req and Rsp.
///</summary>
        public Yodiwo.API.Plegma.eThingsOperation Operation;
        ///<summary> 
///Indicates if the request was successful and this response contains actual data
///</summary>
        public bool Status;
        ///<summary> 
///Array of Yodiwo.API.Plegma.Things that contain data related to the selected Operation, if applicable
///</summary>
        public Yodiwo.API.Plegma.Thing[] Data;
    }
    
    ///<summary> 
///Port Event class: used to describe a new event that should trigger en endpoint, either towards a node or the Cloud Services
///</summary>
    public class PortEvent 
    {
        ///<summary> 
///Yodiwo.API.Plegma.PortEvent.PortKey of the Yodiwo.API.Plegma.Port this message refers to (either generating the event, or receiving the event)
///</summary>
        public string PortKey;
        ///<summary> 
///Contents of the event in string form. See Yodiwo.API.Plegma.Port.State
///</summary>
        public string State;
        ///<summary> 
///Revision number of this update; matches the Port State's internal sequence numbering. See Yodiwo.API.Plegma.Port.State
///</summary>
        public int RevNum;
    }
    
    ///<summary> 
///asynchronous Port Event message The main API message to exchange events between Nodes and the Yodiwo Cloud Service
///Direction: bidirectional (Node->Cloud and Cloud->Node)
///
///</summary>
    public class PortEventMsg : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///Array of Yodiwo.API.Plegma.PortEvent messages
///</summary>
        public Yodiwo.API.Plegma.PortEvent[] PortEvents;
    }
    
    ///<summary> 
///Port State Request. Will result in a response of type Yodiwo.API.Plegma.PortStateRsp
///Direction: node->cloud
///
///</summary>
    public class PortStateReq : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///Type of operation requested
///</summary>
        public Yodiwo.API.Plegma.ePortStateOperation Operation;
        ///<summary> 
///List of PortKeys that the server should send an update for (in conjuction with Yodiwo.API.Plegma.ePortStateOperation.SpecificKeys).
/// If set to null or an empty array then the server will send an update for all relevant PortKeys
///</summary>
        public System.String[] PortKeys;
    }
    
    ///<summary> 
///internal state of a referenced Port
///</summary>
    public class PortState 
    {
        ///<summary> 
///Yodiwo.API.Plegma.PortState.PortKey of the Yodiwo.API.Plegma.Port this message refers to (either generating the event, or receiving the event)
///</summary>
        public string PortKey;
        ///<summary> 
///Contents of port in string form. See Yodiwo.API.Plegma.Port.State
///</summary>
        public string State;
        ///<summary> 
///Revision number of this update; matches the Port State's internal sequence numbering. See Yodiwo.API.Plegma.Port.State
///</summary>
        public int RevNum;
        ///<summary> 
///Specifies the number of active graphs that this port is connected in
///</summary>
        public bool IsDeployed;
    }
    
    ///<summary> 
///Active Port Keys Msg Informs Node of all currently active Ports (i.e. Ports that are connected and active in currently deployed graphs).  Should be used to 1. supress events from inactive ports, allowing more efficient use of medium, 2. sync Port states with the server
///Can be either asynchronous (e.g. at Node connection) or as a response to a PortUpdateReq
///Direction: Cloud -> Node
///See also Yodiwo.API.Plegma.Port.NumOfActiveGraphs
///</summary>
    public class PortStateRsp : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///Type of operation responding to
///</summary>
        public Yodiwo.API.Plegma.ePortStateOperation Operation;
        ///<summary> 
///Array of requested Port states.
///</summary>
        public Yodiwo.API.Plegma.PortState[] PortStates;
    }
    
    ///<summary> 
///Active Port Keys Msg Informs Node of all currently active Ports (i.e. Ports that are connected and active in currently deployed graphs).  Should be used by Nodes to supress events from inactive ports, allowing more efficient use of medium
///Direction: Cloud -> Node
///
///</summary>
    public class ActivePortKeysMsg : Yodiwo.API.Plegma.ApiMsg
    {
        ///<summary> 
///Array of portkeys of currently active Ports
///</summary>
        public System.String[] ActivePortKeys;
    }
    
    
    public class ThingTypes 
    {
        
        public const string Yodiwo_Logic_BlockLibrary_Button = "Actuators.Buttons.Yodiwo.Button";
        
        public const string Yodiwo_Logic_BlockLibrary_FfmpegSource = "VideoSources.Yodiwo.FfmpegSource";
        
        public const string Yodiwo_Logic_BlockLibrary_SipThingOut = "Yodiwo.Logic.BlockLibrary.SipThingOut";
        
        public const string Yodiwo_Logic_BlockLibrary_VideoStreamerThing = "Yodiwo.Logic.BlockLibrary.VideoStreamerThing";
    }
    
    
    public class PlegmaAPI 
    {
        
        public const int APIVersion = 1;
        
        public const System.Char KeySeparator = '-';
        
        public static System.Type[] ApiMessages = new System.Type[] { typeof(Yodiwo.API.Plegma.LoginReq),typeof(Yodiwo.API.Plegma.LoginRsp),typeof(Yodiwo.API.Plegma.NodeInfoReq),typeof(Yodiwo.API.Plegma.NodeInfoRsp),typeof(Yodiwo.API.Plegma.ThingsReq),typeof(Yodiwo.API.Plegma.ThingsRsp),typeof(Yodiwo.API.Plegma.PortEventMsg),typeof(Yodiwo.API.Plegma.PortStateReq),typeof(Yodiwo.API.Plegma.PortStateRsp),typeof(Yodiwo.API.Plegma.ActivePortKeysMsg),};
        
        public static System.Collections.Generic.Dictionary<System.Type, string> ApiMsgNames = new System.Collections.Generic.Dictionary<System.Type, string>() { {typeof(Yodiwo.API.Plegma.LoginReq),"loginreq"} ,{typeof(Yodiwo.API.Plegma.LoginRsp),"loginrsp"} ,{typeof(Yodiwo.API.Plegma.NodeInfoReq),"nodeinforeq"} ,{typeof(Yodiwo.API.Plegma.NodeInfoRsp),"nodeinforsp"} ,{typeof(Yodiwo.API.Plegma.ThingsReq),"thingsreq"} ,{typeof(Yodiwo.API.Plegma.ThingsRsp),"thingsrsp"} ,{typeof(Yodiwo.API.Plegma.PortEventMsg),"porteventmsg"} ,{typeof(Yodiwo.API.Plegma.PortStateReq),"portstatereq"} ,{typeof(Yodiwo.API.Plegma.PortStateRsp),"portstatersp"} ,{typeof(Yodiwo.API.Plegma.ActivePortKeysMsg),"activeportkeysmsg"} ,};
    }
    
    #endregion
}
